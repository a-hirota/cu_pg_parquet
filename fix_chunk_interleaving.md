# チャンクデータのインターリーブ問題と解決策

## 問題の詳細

奇数行でのみ文字列データが破損する問題の根本原因は、Rustの並列COPYプロセスにあります：

1. **並列ワーカーの非同期書き込み**
   - 16個のワーカーが独立してPostgreSQLからデータを取得
   - `worker_offset.fetch_add()`を使って同じファイルに並列書き込み
   - 結果として、異なるワーカーのデータが交互に配置される

2. **行の分断問題**
   - PostgreSQL COPY BINARYフォーマットでは、1行のデータが連続している必要がある
   - ワーカーAが行の前半を書き、ワーカーBが別のデータを書き、その後ワーカーAが行の後半を書く場合がある
   - これにより、パーサーが正しく行を検出できない

3. **奇数行での破損パターン**
   - 偶数行: たまたま1つのワーカーが完全に書き込んだデータ
   - 奇数行: 複数のワーカーによって分断されたデータ

## 解決策

### 1. 短期的解決策: 単一ワーカーモード
```rust
// main_single_chunk.rsを修正
const PARALLEL_CONNECTIONS: usize = 1;  // 1接続に変更
```

### 2. 中期的解決策: ワーカーごとの独立ファイル
```rust
// 各ワーカーが独自のファイルに書き込み
let worker_file = format!("{}/chunk_{}_worker_{}.bin", OUTPUT_DIR, chunk_id, worker_id);
// 最後に全ファイルを結合
```

### 3. 長期的解決策: 行境界を保持した並列処理
- 各ワーカーが完全な行単位でバッファリング
- 行の終端を検出してから書き込み
- または、PostgreSQLのctid範囲を行境界で正確に分割

## 推奨アプローチ

最も簡単で確実な解決策は、**単一ワーカーモード**への変更です。これにより：
- データの連続性が保証される
- パフォーマンスへの影響は限定的（ネットワークI/Oがボトルネック）
- 実装変更が最小限

## 実装手順

1. `rust_bench_optimized/src/main_single_chunk.rs`の`PARALLEL_CONNECTIONS`を1に変更
2. Rustバイナリを再ビルド
3. ベンチマークを再実行して問題が解決することを確認