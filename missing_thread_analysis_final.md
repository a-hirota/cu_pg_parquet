# 欠落thread_id分析結果（最終版）

## 概要
14個の欠落キーの原因は、4個の欠落thread_idにあることが判明しました。

## 欠落thread_idの詳細

| thread_id | 16進数 | 境界位置 | 前thread終了 | 欠落位置（推定） | 後thread開始 |
|-----------|--------|----------|--------------|-----------------|--------------|
| 1048576 | 0x100000 | 192MB | 0x0C000013 | 0x0C000013-0x0C0000D3 | 0x0C0000D3 |
| 1398102 | 0x155556 | 256MB | 0x10000093 | 0x10000093-0x10000153 | 0x10000153 |
| 2097153 | 0x200001 | 384MB | 0x180000D3 | 0x180000D3-0x18000193 | 0x18000193 |
| 2446679 | 0x255557 | 448MB | 0x1C000153 | 0x1C000153-0x1C000213 | 0x1C000213 |

## 重要な発見

1. **すべての欠落は64MB境界付近で発生**
   - 各thread_idは192バイトの固定サイズを処理
   - 欠落thread_idの処理範囲が64MB境界を跨ぐ位置にある

2. **実際のthread配置**
   - thread_strideは1150バイトではなく、実際は192バイト固定
   - 64MBごとに約349,525個のthreadが配置される
   - 実際の位置は計算上の位置（thread_id * 1150）とは全く異なる

3. **欠落パターン**
   - thread_id 1048576は2^20という特殊な値
   - 192MB境界では1048575→1048577へスキップ
   - 256MB境界では1398101→1398103へスキップ
   - 384MB境界では2097152→2097154へスキップ
   - 448MB境界では2446678→2446680へスキップ

## 根本原因

CUDAカーネルが64MB境界を跨ぐthread_idを適切に生成できていない可能性が高い。特に境界付近でthread_idのスキップが発生している。

## 推奨される修正

1. CUDAカーネルのthread_id生成ロジックを確認
2. 64MB境界処理の特別な条件分岐を調査
3. 境界を跨ぐthread_idが適切に生成されるよう修正