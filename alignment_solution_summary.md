# 64MB境界問題の解決状況

## 現在の実装状況

### 実装済み
1. ✅ worker_offset.fetch_add(BUFFER_SIZE)による64MBアライメント
2. ✅ 64MBごとの書き込み（whileループ）
3. ✅ ファイルサイズの事前確保
4. ✅ WorkerMetaにactual_sizeフィールド追加

### 結果
- **改善前**: 303,519行欠落（2.5%）
- **現在**: 1,655,351行欠落（13.8%）
- **状況**: 悪化（アライメントによる未使用領域が原因）

## 問題の原因
現在の実装では、各ワーカーが64MB境界にアライメントされていますが、実際のデータは64MBより少ない場合があります。例：
- ワーカーが53MBのデータを持つ
- 64MB位置にオフセットを進める
- 11MBの未使用領域が発生
- GPU側はこの領域も読もうとして失敗

## 推奨される解決策

### 方法1: GPU側でのオーバーラップ読み取り（最も簡単）
```python
# GPU側で64MB境界付近を重複読み取り
if thread_pos % (64 * 1024 * 1024) < 1024:
    # 256バイト前から読み始める
    actual_start = max(0, thread_pos - 256)
```

### 方法2: メタデータの改善（現在の方向性）
```rust
struct WorkerMeta {
    id: usize,
    offset: u64,          // 開始位置（64MB境界）
    size: u64,            // 予約サイズ（64MB単位）
    actual_size: u64,     // 実際のデータサイズ
    end_offset: u64,      // 実際の終了位置
}
```

### 方法3: スマートバッファリング
最後の不完全な行を検出し、次のワーカーの最初に含める。

## 結論
現在の64MBアライメント実装は技術的には正しいですが、大量のデータ欠落を引き起こしています。100%の精度を達成するには、GPU側での追加処理が必要です。